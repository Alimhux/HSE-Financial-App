## Домашняя работа №2 - Система учета финансов ВШЭ-Банк

### Описание проекта

Система учета финансов для ВШЭ-Банка, разработанная с применением принципов DDD, паттернов проектирования GoF, принципов SOLID и GRASP.

### Архитектура

Проект следует чистой архитектуре с четким разделением на слои:

```
├── Domain Layer (Бизнес-логика)
│   ├── Entities (BankAccount, Category, Operation)
│   ├── Value Objects (Money, DateRange, Types)
│   ├── Repositories (Интерфейсы)
│   ├── Services (Доменные сервисы)
│   └── Factories (Создание сущностей)
│
├── Application Layer (Логика приложения)
│   ├── Commands (Команды)
│   ├── Decorators (Декораторы команд)
│   └── Facades (Фасады)
│
├── Infrastructure Layer (Инфраструктура)
│   ├── Persistence (In-memory репозитории)
│   ├── Proxy (Кэширование)
│   ├── DI Container (Управление зависимостями)
│   └── Serialization (Import/Export)
│
└── Presentation Layer (UI)
    └── Console (Консольный интерфейс)
```

## Реализованные паттерны

### 1. **Factory Method** 

* **Где**: `domain/factories/entity_factory.h`
* **Зачем**: Централизованное создание доменных сущностей с валидацией
* **Преимущества**: Гарантирует создание валидных объектов, избегает дублирования кода валидации

### 2. **Singleton**

* **Где**: `infrastructure/di/di_container.h`
* **Зачем**: Единая точка управления зависимостями
* **Преимущества**: Централизованная конфигурация, управление жизненным циклом объектов

### 3. **Builder** 

* **Где**: `application/facades/analytics_facade.h` (AnalyticsReportBuilder)
* **Зачем**: Пошаговое создание сложных отчетов
* **Преимущества**: Гибкая настройка отчетов, разделение процесса создания и представления

### 4. **Proxy** 

* **Где**: `infrastructure/proxy/caching_proxy.h`
* **Зачем**: Кэширование доступа к репозиториям
* **Преимущества**: Повышение производительности, прозрачное кэширование

### 5. **Decorator** 

* **Где**: `application/decorators/command_decorators.h`
* **Зачем**: Добавление функциональности командам (логирование, измерение производительности)
* **Преимущества**: Гибкое расширение функциональности без изменения базовых классов

### 6. **Facade**

* **Где**: `application/facades/` (AccountFacade, OperationFacade, AnalyticsFacade)
* **Зачем**: Упрощение сложного API
* **Преимущества**: Простой интерфейс для сложных подсистем

### 7. **Command** 

* **Где**: `application/commands/commands.h`
* **Зачем**: Инкапсуляция операций как объектов
* **Преимущества**: Поддержка отмены/повтора, история операций, транзакционность

### 8. **Template Method** 

* **Где**: `infrastructure/serialization/data_importer.h`
* **Зачем**: Определение скелета алгоритма импорта
* **Преимущества**: Переиспользование кода, расширяемость для новых форматов

### 9. **Visitor** 

* **Где**: `infrastructure/serialization/data_exporter.h`
* **Зачем**: Обход структуры данных для экспорта в разные форматы
* **Преимущества**: Добавление новых операций без изменения классов сущностей

### 10. **Strategy** 

* **Где**: Неявно в `domain/services/domain_services.h` (различные алгоритмы аналитики)
* **Зачем**: Взаимозаменяемые алгоритмы анализа
* **Преимущества**: Гибкость выбора алгоритмов

## Принципы SOLID

### Single Responsibility Principle (SRP)

* Каждый класс имеет одну четкую ответственность
* Пример: `Money` - только работа с деньгами, `Validator` - только валидация

### Open/Closed Principle (OCP)

* Классы открыты для расширения, закрыты для модификации
* Пример: Декораторы команд расширяют функциональность без изменения базовых команд

### Liskov Substitution Principle (LSP)

* Подклассы могут заменять базовые классы
* Пример: Любая реализация `IRepository` может использоваться взаимозаменяемо

### Interface Segregation Principle (ISP)

* Узкие, специализированные интерфейсы
* Пример: Отдельные интерфейсы для каждого типа репозитория

### Dependency Inversion Principle (DIP)

* Зависимость от абстракций, а не от конкретных реализаций
* Пример: Все сервисы зависят от интерфейсов репозиториев

## Принципы GRASP

### High Cohesion

* Высокая связность внутри модулей
* Каждый модуль (domain, application, infrastructure) имеет четкую ответственность

### Low Coupling

* Слабая связанность между модулями
* Использование интерфейсов и DI для минимизации зависимостей

### Information Expert

* Ответственность у того, кто владеет данными
* Пример: `BankAccount` управляет своим балансом

### Controller

* `ConsoleUI` выступает контроллером для обработки пользовательского ввода

### Pure Fabrication

* Доменные сервисы для операций, не относящихся к конкретным сущностям

## Функциональность

### Основная функциональность

* Создание, редактирование и удаление счетов
* Создание, редактирование и удаление категорий
* Создание и удаление операций (доходов/расходов)
* Переводы между счетами

### Дополнительная функциональность

#### Аналитика

* Подсчет разницы доходов и расходов за период
* Группировка доходов и расходов по категориям
* Топ категорий по сумме операций
* Отчеты за месяц/год

#### Импорт и экспорт данных

* Экспорт в CSV
* Экспорт в JSON
* Импорт из CSV
* Импорт из JSON (упрощенный)

#### Управление данными

* Проверка балансов
* Автоматический пересчет баланса
* Обнаружение несоответствий

#### Статистика

* Измерение времени выполнения операций
* Статистика производительности команд
* Логирование операций

## DI Container

Проект использует собственный упрощённый DI контейнер для управления зависимостями:

* Регистрация singleton и transient сервисов
* Автоматическое разрешение зависимостей
* Централизованная конфигурация

## Использование проекта

После запуска программы вы увидите главное меню с опциями:

1. **Управление счетами** - создание, просмотр, пополнение, снятие
2. **Управление категориями** - создание категорий доходов/расходов
3. **Управление операциями** - добавление доходов и расходов
4. **Аналитика и отчеты** - различные отчеты и статистика
5. **Импорт/Экспорт данных** - сохранение и загрузка данных
6. **Демонстрация паттернов** - описание реализованных паттернов
7. **Быстрая демонстрация** - автоматическая демонстрация возможностей

## Тестирование

Для быстрого тестирования:

1. Запустите программу
2. Выберите пункт "7. Быстрая демонстрация"
3. Система автоматически создаст тестовые данные и покажет отчет

## Логирование

Все операции логируются в файл `financial_app.log` в директории запуска программы.


Разработано в рамках курса "Конструирование программного обеспечения" НИУ ВШЭ.
